Renewals
  2. renewals don't work
  3. then display renewals, by day, week, month
  4. add a check off like to do list vibe 

rethink renewals logic...

import { Renewal } from './types'; // Your interface

export interface ExpiringRenewal extends Renewal {
  daysOverdue: number;
  status: 'expired' | 'expiring_soon' | 'grace_period';
}

export interface RenewalResolution {
  renewal_id: number;
  action: 'quit' | 'renew';
  resolved_at: string;
  notes?: string;
}

export class RenewalManager {
  private readonly GRACE_PERIOD_DAYS = 7; // Days after expiration to still show as actionable
  private readonly WARNING_PERIOD_DAYS = 14; // Days before expiration to show warnings

  /**
   * Get all renewals that need attention (expired, expiring soon, or in grace period)
   */
  getExpiringRenewals(renewals: Renewal[], currentDate: Date = new Date()): ExpiringRenewal[] {
    const today = new Date(currentDate);
    today.setHours(0, 0, 0, 0); // Start of day for consistent comparison

    return renewals
      .map(renewal => this.processRenewal(renewal, today))
      .filter(renewal => renewal !== null) as ExpiringRenewal[];
  }

  /**
   * Process individual renewal to determine if it needs attention
   */
  private processRenewal(renewal: Renewal, today: Date): ExpiringRenewal | null {
    const expirationDate = new Date(renewal.expiration_date);
    expirationDate.setHours(0, 0, 0, 0);
    
    const daysDiff = Math.floor((today.getTime() - expirationDate.getTime()) / (1000 * 60 * 60 * 24));
    
    // Check if renewal needs attention
    if (daysDiff >= -this.WARNING_PERIOD_DAYS && daysDiff <= this.GRACE_PERIOD_DAYS) {
      let status: 'expired' | 'expiring_soon' | 'grace_period';
      
      if (daysDiff > 0) {
        status = daysDiff <= this.GRACE_PERIOD_DAYS ? 'grace_period' : 'expired';
      } else {
        status = 'expiring_soon';
      }

      return {
        ...renewal,
        daysOverdue: daysDiff,
        status
      };
    }
    
    return null; // Doesn't need attention
  }

  /**
   * Get renewals grouped by status for better UI organization
   */
  getGroupedExpiringRenewals(renewals: Renewal[], currentDate: Date = new Date()) {
    const expiringRenewals = this.getExpiringRenewals(renewals, currentDate);
    
    return {
      expired: expiringRenewals.filter(r => r.status === 'expired'),
      gracePeriod: expiringRenewals.filter(r => r.status === 'grace_period'),
      expiringSoon: expiringRenewals.filter(r => r.status === 'expiring_soon')
    };
  }

  /**
   * Resolve a renewal with student quit action
   */
  async resolveAsQuit(
    renewalId: number, 
    notes?: string,
    supabaseClient?: any // Your Supabase client
  ): Promise<RenewalResolution> {
    const resolution: RenewalResolution = {
      renewal_id: renewalId,
      action: 'quit',
      resolved_at: new Date().toISOString(),
      notes: notes || 'Student quit'
    };

    // Optional: Update student status in database
    if (supabaseClient) {
      await supabaseClient
        .from('students')
        .update({ 
          status: 'inactive',
          quit_date: new Date().toISOString()
        })
        .eq('id', renewalId); // Assuming you get student_id from renewal
    }

    return resolution;
  }

  /**
   * Resolve a renewal by creating next renewal
   */
  async resolveWithNextRenewal(
    currentRenewal: Renewal,
    newRenewalData: Partial<Renewal>,
    supabaseClient?: any
  ): Promise<{ resolution: RenewalResolution; newRenewal: Partial<Renewal> }> {
    // Calculate new renewal dates
    const currentExpiration = new Date(currentRenewal.expiration_date);
    const newStartDate = new Date(currentExpiration);
    newStartDate.setDate(newStartDate.getDate() + 1); // Start day after current expires
    
    const newExpirationDate = new Date(newStartDate);
    newExpirationDate.setMonth(newExpirationDate.getMonth() + (newRenewalData.duration_months || 1));

    const newRenewal: Partial<Renewal> = {
      student_id: currentRenewal.student_id,
      duration_months: newRenewalData.duration_months || 1,
      payment_date: new Date().toISOString(),
      expiration_date: newExpirationDate.toISOString(),
      amount_due: newRenewalData.amount_due || currentRenewal.amount_due,
      amount_paid: newRenewalData.amount_paid || 0,
      number_of_payments: newRenewalData.number_of_payments || 1,
      number_of_classes: newRenewalData.number_of_classes || currentRenewal.number_of_classes,
      paid_to: newRenewalData.paid_to || currentRenewal.paid_to,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    // Optional: Insert new renewal into database
    if (supabaseClient) {
      await supabaseClient
        .from('renewals')
        .insert(newRenewal);
    }

    const resolution: RenewalResolution = {
      renewal_id: currentRenewal.renewal_id,
      action: 'renew',
      resolved_at: new Date().toISOString(),
      notes: `Renewed for ${newRenewal.duration_months} months`
    };

    return { resolution, newRenewal };
  }

  /**
   * Get human-readable status message for UI display
   */
  getStatusMessage(renewal: ExpiringRenewal): string {
    const { daysOverdue, status } = renewal;
    
    switch (status) {
      case 'expired':
        return `Expired ${Math.abs(daysOverdue)} days ago`;
      case 'grace_period':
        return `In grace period (${daysOverdue} days overdue)`;
      case 'expiring_soon':
        return `Expires in ${Math.abs(daysOverdue)} days`;
      default:
        return 'Unknown status';
    }
  }

  /**
   * Get priority level for sorting (higher number = higher priority)
   */
  getPriority(renewal: ExpiringRenewal): number {
    switch (renewal.status) {
      case 'expired': return 3;
      case 'grace_period': return 2;
      case 'expiring_soon': return 1;
      default: return 0;
    }
  }
}

// Usage example:
export function useRenewalManagement() {
  const renewalManager = new RenewalManager();

  const handleRenewalActions = async (
    renewals: Renewal[], 
    supabaseClient: any
  ) => {
    // Get all renewals that need attention
    const expiringRenewals = renewalManager.getExpiringRenewals(renewals);
    
    // Sort by priority (most urgent first)
    expiringRenewals.sort((a, b) => 
      renewalManager.getPriority(b) - renewalManager.getPriority(a)
    );

    return expiringRenewals;
  };

  const quitStudent = async (renewalId: number, notes?: string) => {
    return await renewalManager.resolveAsQuit(renewalId, notes);
  };

  const createNextRenewal = async (
    currentRenewal: Renewal, 
    newRenewalData: Partial<Renewal>
  ) => {
    return await renewalManager.resolveWithNextRenewal(currentRenewal, newRenewalData);
  };

  return {
    renewalManager,
    handleRenewalActions,
    quitStudent,
    createNextRenewal
  };
}

